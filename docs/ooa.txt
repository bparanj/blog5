## Static Modeling
### Objective

Identify domain objects, services, attributes, and their relationships using different techniques, including **parts of speech**.

### What is a Domain Object?

Domain object is an object that consist of domain information only, it usually represents a logical entity in the problem domain. 

### How to Identify Domain Objects?

There are several techniques to identify domain objects and the services provided by them. They are:

- Parts of speech technique
- CRC technique
- Interviewing domain experts
- Conceptual Category List / Common Associations List
- Analysis Patterns [Fowler]

Analysis Patterns is beyond the scope of this book. Let us now discuss other techniques in detail.

### Parts of Speech Technique

In Abbot's linguistic analysis approach (parts of speech) we identify the noun phrases and the verbs in the problem description or system specification to find the classes and their operations.

Verb extraction is used to find the methods. Identify the verbs in the problem statement. These are good candidates for the actions that must be performed by the classes to carry out its responsibilities.
 
Booch finds Abbott's method to be useful due to its simplicity and the fact that it forces the developer to work in the vocabulary of the problem space. The drawback is that the quality of the domain objects depends on the informal specification document. Coad and Yourdan suggest looking for key nouns and verbs in the widest possible variety of domain-related documentation, not just developer-generated domain descriptions.

### Example for Parts of Speech Technique

Let us now see an example that illustrates the parts of speech technique for finding the domain objects. Consider the following statement of requirements for the first iteration of a Library System.
 
Books and Journals : The library contains books and journals. It may have several copies of a given book. Some of the books are for short term loans only. All other books may be borrowed by any library member for three weeks. Members of the library can normally borrow up to six items at a time, but members of staff may borrow up to twelve items at one time. Only members of staff may borrow journals.
 
Borrowing : The system must keep track of when books and journals are borrowed and returned, enforcing the rules described above.
 
Requirements statement with noun and noun phrases in bold is shown below.

**Books** and **Journals** : The library contains books and journals. It may have several copies of a given book. Some of the books are for short term loans only. All other books may be borrowed by any **library member** for three weeks. Members of the library can normally borrow up to six items at a time, but **members of staff** may borrow up to twelve items at one time. Only members of staff may borrow journals.

Borrowing : The system must keep track of when books and journals are borrowed and returned, enforcing the rules described above.
 
According to the Merriam-Webster dictionary, noun is something that is an entity, quality, state, action or concept.
 
Books, Journals, copies of a book are all entity therefore they are nouns and has been underlined. Staff member and library member are noun phrases. Short term is an adjective. Loan can be a noun as well as a transitive verb. Loan is a concept in the above context. We don't have enough information about the loan concept in the description. From the description, we can say "Book is loaned to a library member". This will be modeled in the domain model as a relationship between the Book and LibraryMember with loaned to as the name of the association. Therefore we will eliminate it.
 
Here is a simple and easy way to find out if a given word is a noun or not. Go to [Webster](http://www.merriam-webster.com 'Webster') and just type in the word, the dictionary shows the meaning of the entry and also tells you if it is a noun or not.

## Case Study - Buffet R Us
### Identify the Domain Objects

Let's identify the domain objects for the following system. 

### Problem statement

We are required to develop a payment system for Buffets R Us. Buffets R Us is a restaurant specializing in serving buffets to its customers. Lunch buffet is priced at $ 9.59 per person and dinner buffet is priced at $ 14.79 per person. Beverages are priced separately.

Buffets R Us advertises at a local movie theaters to build its customer base. The customers can turn-in the used movie tickets for a 10% discount on their order. A senior discount of 15% is available for people over the age of 55. Only one discount is applicable at any one time. Kids less than five years old eat free on Tuesdays.

Payment can be made using credit card, personal cheque or cash only. The receipt contains the date and time stamp of the purchase, restaurant name, name of each item and its price, discount type, discount amount, sales tax of 6.5% and the total amount for the purchase.

### Answer

Lunch, Dinner, Payment, CreditCard, Cheque, Cash, Beverage are the set of domain objects for this system. All of these objects represent concepts that are part of the domain model of the payment system.

Examining the nouns in the problem statement can help discover candidate domain objects, but not all nouns will relate directly to the system being designed. Candidate objects that do not have attributes or behavior required by the system are rejected. For example, “theaters” is a noun, but does not have any behavior or attributes required by
the system, so it is rejected. The remaining objects are the core domain objects that will be part of the system.

## Case Study - Automated Movie Ticket System 

### How to Identify Services

This case study is used to illustrate how to identify services. We are commissioned to develop an Automated Movie Ticket System (AMTS) for Movie Brothers R Us. This system will allow the movie goers to browse for the current showings that are playing Users can also search based on show time, artist name or movie name. Users will buy tickets after selecting a movie and a show time, and after inserting any valid discount coupon.

This system will only accept credit card as the payment method. Students can insert their student discount coupons to receive a discount of 20%. Matinee shows are priced at a 40% discount in order to fill up the empty seats.

Once the card is authorized, the system prints the movie tickets with the show time, movie name, date & time and the theater screen number where the movie is played.

Identify the services provided by this AMTS system.

### Answer

browse(), search(), buy(), pay(), charge(), print()

This is the complete list of all services to be provided by the SuD (system under discussion).

Examining the verbs or verb phrases in the problem statement can help discover candidate services that must be provided by the system, but not all of them will relate directly to the system being designed. Candidate verbs or verb phrases that do not describe behavior required by the system are rejected. For example, “insert” is a verb, but it does not describe a behavior to be implemented by the system.

The “matinee” shows get a discount and this is actually a temporal event; the system does not need any input from the actor.

The verb “accept” is not a service to be provided by the system under development. Accepting a credit card is not the service to be provided, the desired service is to charge the credit card.

The verb “receive” is not a service to be provided by the system under development. Receiving a discount is not the service to be provided. Applying the discount is part of the pay service.

The verb “play” is not a service to be provided by the system under development. Playing the movie is the responsibility of the theater, not the system. It is out of scope.

### CRC Technique
CRC technique can also be used to find the domain objects and services. CRC stands for Class-Responsibility-Collaborator. Let's now see how to identify objects using CRC Technique. 

Responsibility-Driven Design is a technique that can be used to identify objects. Responsibilities become attributes and operations after we refine our model. This technique is very helpful to teach beginners about OOAD. Once you become familiar with this approach it becomes easy to think in terms of objects and collaborations. Consequently, developers will be able identify objects mentally. 

This can be used during both the analysis and design phases. The emphasis will shift from what to how when we move from analysis to design. So, the CRC cards will be different for these two phases.

In order to make it easier for the reader to understand the CRC technique, we will use a mini-case study to illustrate the concepts. The emphasis will be on identifying objects and we will make simplifying assumptions to make it easier to swiftly move to implementation stage. This means we will not have any realistic non-functional requirements, legacy constraints etc.

## Case Study
### Customer Credit Card Account Management Program 
**System Description**

The program facilitates a credit card customer service representative (CSR) to maintain and access information about credit cards of the customer. Credit card type, holder’s name, credit card number and expiration date describe each credit card. Customer needs access to their credit card related information such as account balance, available credit, last payment date, last payment amount, any current minimum amount due, due date, past due amount if any. Data is saved in XML format.

A CSR can run the program by logging on using their user id and password. This is due to the need for knowing who made changes or notes on a customer’s credit account. Notes are made to record notification of late payment by the customer, request for credit line increase, report of lost or stolen credit card, report of unauthorized charges, dispute related information etc. Once the CSR logins into the system, they can pull up the customer related information by entering the credit card number and doing search to get the related information. The screen shows customer’s authentication information such as their social security number, security question and answer and date of birth. A CSR must authenticate the customer before making any modifications or giving out any information related to that particular customer account. Customer record includes their current address, contact number and account holder name.

Let us now move on from the initial specification to writing main success scenario for most frequently used use cases. We will defer the alternative path related work to the next iteration. The interaction between the system and the actor will be documented in a user interface intensive terms at a high level of abstraction. This is because we will know what data is going into and out of the system. This is a short-cut that we are taking for the purpose of our case study. In reality the users and domain experts will provide input on what information they will be providing and expecting from the system.

We have selected **Record Dispute** as the most frequently used use case because we are making the assumption that the use cases that are most frequently used are **Retrieve** type of use case and this information can be given by the automated system over the phone. The phone interface is not capable of handling dispute charges. Our program therefore will focus more on functionality provided to the CSRs. CSR is capable of resolving the dispute and in some cases provide immediate resolution in favor of the customer depending on the situation.

### Scenarios

**Scenario 1** CSR selects “Record Dispute” from the menu.

**High-level interaction**
1. CSR selects “Record Dispute” from the menu.
2. System displays a new screen that can capture all the dispute related information.
3. Customer provides the merchant name, transaction amount, transaction date and the reason for dispute. CSR enters this information into the system and saves it.

**Scenario 2** : Customer wants to update address.
**High-level interaction**
1. CSR pulls up the account information related to the customer by searching on the account number. The customer record contains social security number, date of birth, current address and the security question
2. CSR requests the customer to identify himself and checks the information with that of the system. CSR selects change address.
3. System prompts for new address.
4. CSR enters the new address and updates the system.

We will use the above two scenarios to illustrate the CRC technique.

### Identifying Candidate Classes 

Let us use parts of speech technique to find the candidate classes. Underline the nouns and noun phrases in the specification document to get a list of potential classes. Merriam-Webster dictionary defines noun as any member of a class of words that typically can be combined with determiners to serve as the subject of a verb, can be interpreted as singular or plural, can be replaced with a pronoun, and refer to an entity, quality, state, action, or concept

**Step** 1 : Identify candidate classes from specification document.
The candidate classes are in bold in the following specification document.

The program facilitates a **credit card customer service representative** (CSR) to maintain and access information about credit cards of the **customer**. **Credit card type**, **holder’s name**, **credit card number** and **expiration date** describe each credit card. Customer needs access to their credit card related information such as **account balance**, **available credit**, **last payment date**, **last payment amount**, any **current minimum amount due**, **due date**, **past due amount** if any. Data is saved in XML format.

A CSR can run the program by logging on using their **user id** and password. This is due to the need for knowing who made changes or notes on a customer’s **credit account**. **Notes** are made to record notification of late payment by the customer, request for **credit line** increase, report of lost or stolen credit card, report of unauthorized charges, dispute related information etc. Once the CSR logins into the system, they can pull up the customer related information by entering the credit card number and doing search to get the related information. The screen shows customer’s authentication information such as their **social security number**, **security question** and **answer** and **date of birth**. A CSR must authenticate the customer before making any modifications or giving out any information related to that particular customer account. Customer record includes their **current address**, **contact number** and **account holder name**.

**Step 2** – Identify candidate classes from scenarios.

Parts of speech technique has the draw back of looking at only the specification for the candidate classes. We will miss classes that will be required for implementation if we do not look at other sources. Therefore let us look for candidate classes in our scenarios as well.

**Scenario 1**: CSR selects *Record Dispute* from the menu.

**High-level interaction**: 
1. CSR selects **Record Dispute** from the menu.
2. System displays a new screen that can capture all the dispute related information.
3. Customer provides the merchant name, transaction amount, transaction date and the reason for dispute. CSR enters this information into the system and saves it.

**Scenario 2**: Customer wants to update address.

**High-level interaction**:
1. CSR pulls up the **account** information related to the customer by searching on the **account number**. The customer record contains **social security number**, **date of birth**, **current address** and the **security question**
2. CSR requests the customer to identify himself and checks the information with that of the system. CSR selects change address.
3. System prompts for **new address**.
4. CSR enters the new address and updates the system.

**Step 3 – Create Candidate Class List**

**Candidate Classes**

1. Credit card
2. Customer service representative
3. Customer
4. Credit Card type
5. Holder’s name
6. Credit card number
7. Expiration Date
8. Account Balance
9. Available Credit
10. Last Payment Date
11. Last payment amount
12. Current minimum amount due
13. Due date
14. Past due amount
15. User id
16. Password
17. Credit Account
18. Notes
19. Credit Line
20. Social Security Number
21. Security Question
22. Security Answer
23. Date of birth
24. Current Address
25. Contact Number
26. Account Holder Name
27. Record Dispute
28. Merchant Name
29. Transaction Amount
30. Transaction Date
31. Dispute Reason
32. Account Number
33. Account
34. New Address

We have combined the candidate classes from the specification and the scenarios. We have also eliminated any duplicate entries in our list. Now we are ready to move on to the next step, which is filtering the candidate classes to find the final list of classes.

**Step 4 – Triage the Candidate Classes**

Let us now go through our selection of nouns and check if they can be moved from a candidate class list to required class list.

- *Credit card*. The Credit card consists of account holder’s name, credit card number, expiration date and credit card type. We need this class for implementation therefore we will move this to our class list.
- *Customer service representative*. This is just an actor. Is this part of our system? Does the system keep track of anything related to CSR? The answer is yes, but only for the purposes of keeping track of who made changes or added notes to a customer account. We will keep this class.
- *Customer*. We maintain the customer information in the system. These are cardholder’s name, current address, date of birth, social security number and credit card number owned by the customer. We will implement this as a class.
- *Credit Card type*. This is just a String (Master Card, Visa, Amex, Discover etc) and is an attribute that belongs to Credit card class that we discovered above.
- ~~Holder’s name~~. This is the same as the Account Holder’s name listed below.
- *Credit card number*. This is a number that can be represented as an Integer. It is an attribute that belongs to Credit Card class.
- *Expiration Date*. This is a Date object and is an attribute that belongs to Credit Card class.
- *Account Balance*.  This is a number and can be represented by a real number. This is an attribute of Credit Account class (listed below in this list).
- *Available Credit*. A real number represent amount of credit available. It is another attribute of Credit Account class.
- *Last Payment Date*. A Date is an object and is an attribute of Last Payment class. Last Payment will be a new class that will hold all the information related to the previous statement.
- *Last payment amount*. A real number and an attribute of Last Payment class.
- *Current minimum amount due*. A real number and an attribute of Current Payment class (a new class to hold all the relevant attributes and behavior).
- *Due date*. A Date object and an attribute of Current Payment class.
- *Past due amount*. A real number and an attribute of Current Payment & Last Payment class.
- *User id*. This is a String and is an attribute that belongs to Login Account used by CSR to login to the system.
- *Password*. Same as above.
- *Credit Account*. This is an important concept and must be implemented as a class. This will hold all the data and behavior associated with the credit card account of the customer. 
- *Notes*. This is String object holding the information related to the communication between the CSR and the customer. Unknown during first pass on this list. After the first pass is made on this list we have made a decision to let this be part of Record Dispute class (which is below).
- *Credit Line*. A real number that belongs to the Credit Account class discovered above.
- *Social Security Number*. A number that is an attribute of the Customer class.
- *Security Question*. A String that is an attribute of some class. We don’t know what it will be yet. We might define a Authenticate or Identify class.
- *Security Answer*. Same as above.
- *Date of birth*. A Date class and is an attribute of Customer class.
- *Current Address*. This is a class by itself; we will implement a class called Address that will have street name, zip, city and state attributes. This is required due to the application requirements.
- *Contact Number*. An Integer that is an attribute of Customer class.
- *Account Holder Name*. A String that is an attribute of Credit Card class.
- *Record Dispute*.  This is a class that will have all the data and behavior related to the dispute.
- *Merchant Name*. A String that is an attribute of Record Dispute class.
- *Transaction Amount*. A real number and an attribute of Record Dispute class.
- *Transaction Date*. A Date object and an attribute of Record Dispute class.
- *Dispute Reason*. A String that is an attribute of Record Dispute class.
- ~~Account Number~~. This is the same as the Credit Card Number. We will combine the two names representing the same concept with just one name, Credit Card Number. Therefore, this is eliminated.
- *Account*. This concept is already captured by Credit Account. We will eliminate this candidate class from the list.
- *New Address*. This is the same type as Address that we have already discovered. So, we don’t need a new class to implement this concept.

**Step 5 – Required Class List**

We now have the following list of classes that we need to design and implement in our system.

- *Credit card*
- *Customer service representative*
- *Customer*
- *Last Payment* 
- *Current Payment*
- *Credit Account*
- *Address*
- *Record Dispute*
  
**Step 6 – List of Attributes Identified During the Triage of Candidate Classes**

- *Credit Card type*.  Credit card class 
- *Credit card number*. Credit Card class.
- *Expiration Date*.  Credit Card class.
- *Account Balance*. Credit Account class 
- *Available Credit*. Credit Account class.
- *Last Payment Date*. Last Payment class. 
- *Last payment amount*.  Last Payment class.
- *Current minimum amount due*. Current Payment class 
- *Due date*.  Current Payment class.
- *Past due amount*. Current Payment & Last Payment class.
- *User id*. Login Account class.
- *Password*. Login Account class.
- *Notes*. Record Dispute class. 
- *Credit Line*. Credit Account class.
- *Social Security Number*. Customer class.
- *Security Question*. Authenticate or Identify class.
- *Security Answer*. Same as above.
- *Date of birth*.  Customer class.
- *Contact Number*. Customer class.
- *Account Holder Name*. Credit Card class.
- *Merchant Name*. Record Dispute class.
- *Transaction Amount*. Record Dispute class.
- *Transaction Date*. Record Dispute class.
- *Dispute Reason*. Record Dispute class.

**Step 7 – List of Attributes Categorized According to the Class where it belongs** 

Credit Account
- Account Balance
- Available Credit
- Credit Line

Last Payment
- Last Payment Date
- Last payment amount 
- Past due amount

Current Payment
- Current minimum amount due
- Due date
- Past due amount

Login Account
- User id
- Password

Identify 
- Security Question
- Security Answer

Credit Card
- Account Holder Name
- Expiration Date
- Credit Card Number
- Credit card type
- Expiration Date

Record Dispute
- Merchant Name
- Transaction Amount 
- Transaction Date
- Dispute Reason
- Notes

Customer
- Contact Number
- Date of birth
- Social Security Number

**Step 8 – Identify Class Responsibilities**

The functionality required by the system is described in the use cases. The classes that collaborate together will implement the functionality and each class will have some responsibilities that it carries out during this activity. We can expand the high-level interactions into collaborations between classes and document the responsibilities that emerge.

Each class will have a CRC card with the following information on it.
1. Class name
2. Attributes
3. Responsibilities
4. Collaborators
5. Short description of the purpose of the class

The short description is written on the back of the card. For instance for Credit Card class, it will be: *"I maintain all the information related to Credit Card and provide any required operations on my data to my clients"*.

When you trace the use case scenarios with the CRC cards record all the information indicated above. During the trace if you find that you need a new class, we can create a new card for the new class and record the related information on it.

**Scenario 1**: CSR selects *Record Dispute* from the menu.

**High-level interaction**: 
1. CSR selects “Record Dispute” from the menu.
2. System displays a new screen that can capture all the dispute related information.
3. Customer provides the merchant name, transaction amount, transaction date and the reason for dispute. CSR enters this information into the system and saves it.

Class-level interaction:
1. CSR select “Record Dispute” from the menu. 
2. Record Dispute UI is displayed on the screen. 
3. Record Dispute Controller saves the Credit Account and the corresponding Record Dispute in the system.

As we work at a lower level of abstraction we find that we must associate an account to a dispute. Otherwise we will not know which customer filed a dispute. We also have discovered that we need a new class called Record Dispute Controller. This class hooks up the UI to the domain classes Credit Account and Record Dispute. Let us now document the responsibilities on the CRC cards.

**Class: Record Dispute Controller**

**Responsibilities**:
-	To respond to the user-interface events.
-	To delegate work to the appropriate domain classes.
-	To display the results to the user.

**Collaborators**:
-	RecordDisputeUI
-	CreditAccount
-	RecordDispute

Back of the card:

**Description**: I am the use case controller responsible for connecting the user interface to the domain classes. I encapsulate control logic.

**Attributes**:
Let us leave this blank for now. We do not need to be exhaustive while filling out the CRC card. We must avoid analysis paralysis. 

CRC card format

Front of the CRC card

DIAGRAM GOES HERE

Back of the CRC card

DIAGRAM GOES HERE

You can think of a CRC card with the front as the public view and the back as the private view with implementation details. The CRC should contain Class name, Responsibilities and Collaborators section as the minimum. Attributes are considered implementation details and must be shown on the back of the card.

**Class: Record Dispute**

**Responsibilities**:
-	Create a dispute record in the system.
-	Provide access to existing dispute record.

**Collaborators**:
Record Dispute UI

Description: I maintain all the information related to dispute and provide any required operations on my data to my clients

**Attributes**:
- Merchant Name
- Transaction Amount 
- Transaction Date
- Dispute Reason
- Notes

Note: We can rename the RecordDispute to DisputeRecord (verb phrase is changed to noun phrase due to the naming convention for classes).

**Scenario 2: Customer wants to update address.**

**High-level interaction**:
1.	CSR pulls up the account information related to the customer by searching on the account number. The customer record contains social security number, date of birth, current address and the security question
2.	CSR requests the customer to identify himself and checks the information with that of the system. CSR selects change address.
3.	System prompts for new address.
4.	CSR enters the new address and updates the system.

**Class-level interaction**:
1.	CSR enters account number of the customer and does a search for the account.
2.	Credit Account UI detects the user-interface search event and delegates the search functionality to Credit Account Manager class.
3.	Credit Account Manager searches to find the account information corresponding to the account number of the customer. 
4.	Credit Account Manager returns the Credit Account class. 
5.	Credit Account UI queries the Credit Account class for the required fields and displays the information.
6.	CSR selects the change address from the menu. 
7.	Credit Account UI responds to the change address user-interface event and prompts for new address.
8.	CSR enters the new address and clicks update address. Credit Account UI sends the new address data and delegates the update operation to the Account Manager class.
9.	Account Manager class updates the system with the new address.

**Class: Credit Account UI**

**Responsibilities**:
- Provide the UI for the credit account related information.
- Delegate work to the Credit Account Manager class.

**Collaborators**:

- Credit Account Manager
- Credit Account

**Description**: I provide the user interface to the credit account information and delegate all the functionality to a controller class.

**Attributes**: none (for now)


**Class: Credit Account Manager**

**Responsibilities**:
1.	Provide access to the existing credit account information.
2.	Provide search by account number functionality to find credit account.

**Collaborators**:

- Credit Account UI
- Credit Account

**Description**: I encapsulate the control logic for searching and retrieve account related data used by my clients.

**Attributes**: none (for now)


**Class: Credit Account**

**Responsibilities**:
- Provide access to the credit account information.

**Collaborators**:

- Credit Account Manager
- Credit Account

**Description**: I provide the data and access to the credit account related information to my clients.

**Attributes**: 
-	Account Balance
-	Available Credit
-	Credit Line

We can repeat the procedure outlined above to all other scenarios. Once we have a complete set of CRC cards documented we need to verify that each class is capable of providing the functionality documented in the scenarios. If we had missed any responsibility then we need to add them. If there are responsibilities that are not required then it must be removed from the classes.

The main advantage of the CRC cards is their flexibility. It is very easy to move the CRC cards around to see how they collaborate and make changes to the CRC cards. This is very much like Agile Modeling. This technique is extremely useful during the analysis phase when the requirements are fluid. During the design phase we can add more details to the CRC cards such as define the data types of the attributes, include classes to satisfy non-functional requirements etc. Keep in mind that we work with cards that are limited in size and we may not prefer to work with CRC cards during the design phase at all. 

The real question is *Where does the CRC technique fit in the big picture?* The answer is that they find their use in modeling the vocabulary of the system. In other words, CRC cards in conjunction with use case-based analysis can aid us in the discovery of abstractions in both the problem and the solution domain. They are also used when we are modeling structural relationships. By using CRC cards in combination with use case analysis we can identify the classes that must interact. These interacting classes must have an association between them. Larman calls this as *need to know* associations. It is noteworthy to mention that CRC technique forces us to look at the structural and behavioral scenarios. This concludes our simple introduction to the CRC technique.

### Interviewing Domain Experts
 
Domain objects can be identified by interviewing domain experts or from requirements document. The domain objects can be categorized into following three types:

1. Business objects that are things used in a business. These are abstractions such as invoice, account etc.
2. Real-world objects or concepts that a system keeps track. E.g., Book, Boat etc.
3. Events that occur such as gate closing, train arrival etc.
 
This technique can also be used to find the services provided by the objects. Domain experts have very good knowledge in their domain. Interview domain experts and use abstraction to identify classes and services. This approach utilizes their domain expertise and is likely to result in a high quality domain model.
 
Also this technique can be used in conjunction with other techniques to find the missing domain objects and services. This will improve the quality of the domain model. If this is the case then we get feedback from the domain experts for the results we got from other techniques.
 
Major drawbacks include that it can result in analysis paralysis (how many experts? what if they disagree?) and the inability to trace the abstractions back to requirements.

## Conceptual Category List 

A conceptual category list [Larman] can be used to identify the domain objects. In this technique we can use the list of categories as a crutch to discover the domain objects. Study the requirements and determine items from the problem that belongs to a certain category. This is also called as Common Associations List.
 
Similarly common associations list can be used to identify the relationships between the domain objects. Seek common relationship patterns in the interactions between classes and objects and invent ways to use these patterns.  Evaluate the semantic relationships and seek to maximize coupling among things that are semantically related while minimizing coupling among things that are semantically distant and subject to change.
 
The disadvantage is that we may get stuck at some point when something does not seem to fit well in the category list. In such a situation remember that no there is no such thing as *the perfect* domain model. It is just more or less valuable tool in understanding the domain. If we capture all the important concepts and their relationships in the domain then we can get a good domain model.
 
All of the above techniques can be combined to identify classes and services depending on the situation, so that we optimally use the different approaches based on their strengths to arrive at a good domain model.
 
## Identifying Attributes

To find the attributes of a class ask yourself the following questions:
- What does the class know?
- What information should be stored by the class?

We will discuss this in further detail below when we develop a domain model.
 
## Developing a Domain Model

For very small business domains, domain model is not required; a glossary of terms will be sufficient. Domain model should only be concerned with the problem domain and should not include anything related to solution domain. The main purpose of the domain model is as a communication tool between the developers and other non-technical staff. This is the reason why we do not include anything related to the solution domain.

The sequence of activities shown in this eBook is for learning purposes only. In real world, OOAD skills that you apply will not be rigid or follow a linear structure. 

## Identify Classes
 
Class is a template that defines the structure and behavior of an object. It defines the data (state) and methods (behavior) that all objects of that class will possess.

An object is characterized by responsibilities, semantic integrity constraints, types and relationships. Meriam Webster defines the term semantic as related to meaning. An example of a semantic integrity constraint on a class called Reservation would be *Number of rooms reserved cannot be zero or negative*. These rules are the contraints on the data values of the object that impose the business rules. From a programming standpoint, you must throw an exception to indicate invalid data passed to the methods in a class. This prevents violation of the data integrity in the system.

To identify classes, make a list of key nouns from use cases. These are candidate classes. Synonyms  must be merged into one term and documented.

Classes can be found by using the following categories:

1. Tangible things (e.g., Book, Apple, Credit card application form)
2. External systems (i.e., actors, e.g., Credit Bureau)
3. Devices the system interacts with (library card scanner, receipt printer)
4. Locations of things (Concert Hall, Exhibit Room)
5. Roles of people or systems (Teacher, Credit Authorizer)
6. Organizations (Hospital, Finance department)
7. Events (signing a lease or shifting a gear)
8. Remembered events (time of delivery of a package, date of signing a lease)

## Identify Attributes of a Class

Find the data that a class needs to maintain its state. The decision whether to represent the data as an attribute or derive it when required depends on speed vs space trade off. E.g., total debts owned to all creditors by a credit counseling service customer.

Keep the data in the class where it is used most of the time. During the triage on the candidate classes, eliminate any classes that provide the functions of a primitive data type such as string etc. It becomes an attribute.

## Identify methods
 
Make a list of all the verbs in the use cases. These become a list of probable methods. Similar to the classes any synonyms must be merged into one term and documented.
 
We have discussed about identifying responsibilities and attributes in the requirements modeling chapter. This is during the analysis phase, therefore each responsibility of a class may have to mapped on to several methods when we design. The attributes that we found in that chapter are related to the problem domain only.

## Class Design

Following are the important concepts to know about design class:

-	Operations, parameters, attributes etc use the programming language syntax that has been selected for implementation.
-	Visibility of attributes and operations are specified using the keywords of the selected programming language (If it is Java; public, protected, private are used)
-	The relationships between design classes have meaning when it is implemented. Egs: Generalization becomes inheritance in the programming language. Associations and aggregations often maps to variables of classes in the implementation phase. This provides references among objects.
-	A design class can represent an interface if the programming language supports it.

A class interface is the list of operations that is provided by the class to its clients.
 
**Note**: This is different from interface that specifies a contract that must be implemented by a class when it extends (implements) the interface.

When we identify the operations the resulting set of operations may not be sufficient for other applications. This is due to our use case driven development process. Since our use cases are specific to the application under development. It may not require certain operations that might be required in other applications.

Use case driven approach results in minimal set of operations for a class. At the end of the project, there can be a separate phase allocated for looking for objects that can be reused. This topic is beyond the scope of the exam.

Before we discuss the various techniques to find operations, we must keep in mind that the discovery of operations is done during the design phase. Therefore, we must communicate with the stakeholders and ask them if they need this functionality. If they had overlooked or could not foresee the need this requirement then we need to update other artifacts such as use cases, design class diagram and anything else that might be affected. If it is not required then we can discard this operation. Of course no update would be needed in that case. 

Design of operations depends on the trade-off priorities dictated by the requirements. Some of the factors involved during this trade-off are: memory usage, efficiency, re-usability, maintainability etc.




